import test from 'node:test';
import assert from 'node:assert';
import convert from '.';
test('basic conversion with minimal config', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES2020',
            module: 'CommonJS'
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.target, 'es2020');
    assert.strictEqual(result.module?.type, 'commonjs');
    assert.strictEqual(result.jsc?.parser?.syntax, 'typescript');
});
test('JSX configuration mapping', ()=>{
    const tsconfig = {
        compilerOptions: {
            jsx: 'ReactJSX',
            jsxImportSource: '@emotion/react'
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.parser?.jsx, true);
    assert.strictEqual(result.jsc?.parser?.tsx, true);
    assert.strictEqual(result.jsc?.transform?.react?.runtime, 'automatic');
    assert.strictEqual(result.jsc?.transform?.react?.importSource, '@emotion/react');
});
test('decorators configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            experimentalDecorators: true,
            emitDecoratorMetadata: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.parser?.decorators, true);
    assert.strictEqual(result.jsc?.transform?.legacyDecorator, true);
    assert.strictEqual(result.jsc?.transform?.decoratorMetadata, true);
});
test('path mapping configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            baseUrl: './src',
            paths: {
                '@/*': [
                    './src/*'
                ],
                '@components/*': [
                    './src/components/*'
                ]
            }
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.baseUrl, './src');
    assert.deepStrictEqual(result.jsc?.paths, {
        '@/*': [
            './src/*'
        ],
        '@components/*': [
            './src/components/*'
        ]
    });
});
test('source maps configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            sourceMap: true,
            inlineSources: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.sourceMaps, true);
    assert.strictEqual(result.inlineSourcesContent, true);
});
test('inline source maps configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            inlineSourceMap: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.sourceMaps, 'inline');
});
test('module interop configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            esModuleInterop: false,
            strict: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.module?.noInterop, true);
    assert.strictEqual(result.module?.strict, true);
});
test('external helpers configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            importHelpers: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.externalHelpers, true);
});
test('comments preservation', ()=>{
    const tsconfig = {
        compilerOptions: {
            removeComments: false
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.preserveAllComments, true);
});
test('class fields configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            useDefineForClassFields: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.transform?.useDefineForClassFields, true);
});
test('const enum preservation', ()=>{
    const tsconfig = {
        compilerOptions: {
            preserveConstEnums: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.transform?.treatConstEnumAsEnum, true);
});
test('target mapping for all ES versions', ()=>{
    const targets = [
        {
            ts: 'ES3',
            swc: 'es3'
        },
        {
            ts: 'ES5',
            swc: 'es5'
        },
        {
            ts: 'ES6',
            swc: 'es2015'
        },
        {
            ts: 'ES2015',
            swc: 'es2015'
        },
        {
            ts: 'ES2016',
            swc: 'es2016'
        },
        {
            ts: 'ES2017',
            swc: 'es2017'
        },
        {
            ts: 'ES2018',
            swc: 'es2018'
        },
        {
            ts: 'ES2019',
            swc: 'es2019'
        },
        {
            ts: 'ES2020',
            swc: 'es2020'
        },
        {
            ts: 'ES2021',
            swc: 'es2021'
        },
        {
            ts: 'ES2022',
            swc: 'es2022'
        },
        {
            ts: 'ESNext',
            swc: 'esnext'
        }
    ];
    for (const { ts, swc } of targets){
        const result = convert({
            compilerOptions: {
                target: ts
            }
        });
        assert.strictEqual(result.jsc?.target, swc, `Target ${ts} should map to ${swc}`);
    }
});
test('module mapping for all module types', ()=>{
    const modules = [
        {
            ts: 'CommonJS',
            swc: 'commonjs'
        },
        {
            ts: 'AMD',
            swc: 'amd'
        },
        {
            ts: 'UMD',
            swc: 'umd'
        },
        {
            ts: 'ES6',
            swc: 'es6'
        },
        {
            ts: 'ES2015',
            swc: 'es6'
        },
        {
            ts: 'ES2020',
            swc: 'es6'
        },
        {
            ts: 'NodeNext',
            swc: 'nodenext'
        },
        {
            ts: 'Node16',
            swc: 'nodenext'
        }
    ];
    for (const { ts, swc } of modules){
        const result = convert({
            compilerOptions: {
                module: ts
            }
        });
        assert.strictEqual(result.module?.type, swc, `Module ${ts} should map to ${swc}`);
    }
});
test('JSX mapping for all JSX modes', ()=>{
    const jsxModes = [
        {
            ts: 'React',
            expectJsx: true,
            expectTsx: true,
            expectRuntime: 'classic'
        },
        {
            ts: 'ReactJSX',
            expectJsx: true,
            expectTsx: true,
            expectRuntime: 'automatic'
        },
        {
            ts: 'ReactJSXDev',
            expectJsx: true,
            expectTsx: true,
            expectRuntime: 'automatic',
            expectDev: true
        },
        {
            ts: 'Preserve',
            expectJsx: true,
            expectTsx: true,
            expectRuntime: undefined
        },
        {
            ts: 'None',
            expectJsx: false,
            expectTsx: false,
            expectRuntime: undefined
        }
    ];
    for (const mode of jsxModes){
        const result = convert({
            compilerOptions: {
                jsx: mode.ts
            }
        });
        assert.strictEqual(result.jsc?.parser?.jsx, mode.expectJsx, `JSX ${mode.ts} should set jsx to ${mode.expectJsx}`);
        assert.strictEqual(result.jsc?.parser?.tsx, mode.expectTsx, `JSX ${mode.ts} should set tsx to ${mode.expectTsx}`);
        if (mode.expectRuntime) {
            assert.strictEqual(result.jsc?.transform?.react?.runtime, mode.expectRuntime, `JSX ${mode.ts} should set runtime to ${mode.expectRuntime}`);
            if (mode.expectDev) {
                assert.strictEqual(result.jsc?.transform?.react?.development, true, `JSX ${mode.ts} should set development to true`);
            }
        } else {
            assert.strictEqual(result.jsc?.transform?.react, undefined, `JSX ${mode.ts} should not set react transform`);
        }
    }
});
test('comprehensive real-world Node.js configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES2020',
            module: 'CommonJS',
            lib: [
                'ES2020'
            ],
            moduleResolution: 'Node',
            esModuleInterop: true,
            allowSyntheticDefaultImports: true,
            strict: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
            declaration: true,
            declarationMap: true,
            outDir: 'dist',
            rootDir: 'src',
            sourceMap: true,
            importHelpers: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.target, 'es2020');
    assert.strictEqual(result.module?.type, 'commonjs');
    assert.strictEqual(result.sourceMaps, true);
    assert.strictEqual(result.jsc?.externalHelpers, true);
});
test('comprehensive React application configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES2020',
            lib: [
                'DOM',
                'DOM.Iterable',
                'ES6'
            ],
            allowJs: true,
            skipLibCheck: true,
            esModuleInterop: true,
            allowSyntheticDefaultImports: true,
            strict: true,
            forceConsistentCasingInFileNames: true,
            noFallthroughCasesInSwitch: true,
            module: 'ESNext',
            moduleResolution: 'Node',
            resolveJsonModule: true,
            isolatedModules: true,
            noEmit: true,
            jsx: 'ReactJSX',
            jsxImportSource: '@emotion/react'
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.target, 'es2020');
    assert.strictEqual(result.module?.type, 'es6');
    assert.strictEqual(result.jsc?.parser?.jsx, true);
    assert.strictEqual(result.jsc?.transform?.react?.runtime, 'automatic');
    assert.strictEqual(result.jsc?.transform?.react?.importSource, '@emotion/react');
});
test('library configuration with decorators', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES2017',
            module: 'UMD',
            lib: [
                'ES2017'
            ],
            declaration: true,
            outDir: './lib',
            strict: true,
            experimentalDecorators: true,
            emitDecoratorMetadata: true,
            useDefineForClassFields: false,
            preserveConstEnums: true
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.target, 'es2017');
    assert.strictEqual(result.module?.type, 'umd');
    assert.strictEqual(result.jsc?.parser?.decorators, true);
    assert.strictEqual(result.jsc?.transform?.legacyDecorator, true);
    assert.strictEqual(result.jsc?.transform?.decoratorMetadata, true);
    assert.strictEqual(result.jsc?.transform?.useDefineForClassFields, false);
    assert.strictEqual(result.jsc?.transform?.treatConstEnumAsEnum, true);
});
test('empty compilerOptions should use defaults', ()=>{
    const tsconfig = {};
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.target, 'es5');
    assert.strictEqual(result.jsc?.parser?.syntax, 'typescript');
});
test('minimal compilerOptions should work', ()=>{
    const tsconfig = {
        compilerOptions: {}
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.target, 'es5');
    assert.strictEqual(result.jsc?.parser?.syntax, 'typescript');
});
test('ES3 target conversion', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES3'
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.target, 'es3');
});
test('complex JSX factory configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            jsx: 'React',
            jsxFactory: 'h',
            jsxFragmentFactory: 'Fragment'
        }
    };
    const result = convert(tsconfig);
    assert.strictEqual(result.jsc?.transform?.react?.runtime, 'classic');
    assert.strictEqual(result.jsc?.transform?.react?.pragma, 'h');
    assert.strictEqual(result.jsc?.transform?.react?.pragmaFrag, 'Fragment');
});
test('syntax detection based on TypeScript features', ()=>{
    const tsconfigWithTSFeatures = {
        compilerOptions: {
            experimentalDecorators: true,
            strictNullChecks: true
        }
    };
    const result = convert(tsconfigWithTSFeatures);
    assert.strictEqual(result.jsc?.parser?.syntax, 'typescript');
    const tsconfigMinimal = {
        compilerOptions: {
            target: 'ES2020'
        }
    };
    const result2 = convert(tsconfigMinimal);
    assert.strictEqual(result2.jsc?.parser?.syntax, 'typescript');
});
test('returns valid SWC JscTarget types', ()=>{
    const validTargets = [
        'es3',
        'es5',
        'es2015',
        'es2016',
        'es2017',
        'es2018',
        'es2019',
        'es2020',
        'es2021',
        'es2022',
        'esnext'
    ];
    const tsconfig = {
        compilerOptions: {
            target: 'ES2020'
        }
    };
    const result = convert(tsconfig);
    // Verify the target is one of the valid JscTarget values
    assert(validTargets.includes(result.jsc?.target), `Target ${result.jsc?.target} should be a valid JscTarget`);
    // Verify it's specifically es2020 for ES2020 input
    assert.strictEqual(result.jsc?.target, 'es2020');
});
