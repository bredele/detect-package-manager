"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _nodetest = /*#__PURE__*/ _interop_require_default(require("node:test"));
const _nodeassert = /*#__PURE__*/ _interop_require_default(require("node:assert"));
const _ = /*#__PURE__*/ _interop_require_default(require("."));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
(0, _nodetest.default)('basic conversion with minimal config', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES2020',
            module: 'CommonJS'
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.target, 'es2020');
    _nodeassert.default.strictEqual(result.module?.type, 'commonjs');
    _nodeassert.default.strictEqual(result.jsc?.parser?.syntax, 'typescript');
});
(0, _nodetest.default)('JSX configuration mapping', ()=>{
    const tsconfig = {
        compilerOptions: {
            jsx: 'ReactJSX',
            jsxImportSource: '@emotion/react'
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.parser?.jsx, true);
    _nodeassert.default.strictEqual(result.jsc?.parser?.tsx, true);
    _nodeassert.default.strictEqual(result.jsc?.transform?.react?.runtime, 'automatic');
    _nodeassert.default.strictEqual(result.jsc?.transform?.react?.importSource, '@emotion/react');
});
(0, _nodetest.default)('decorators configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            experimentalDecorators: true,
            emitDecoratorMetadata: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.parser?.decorators, true);
    _nodeassert.default.strictEqual(result.jsc?.transform?.legacyDecorator, true);
    _nodeassert.default.strictEqual(result.jsc?.transform?.decoratorMetadata, true);
});
(0, _nodetest.default)('path mapping configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            baseUrl: './src',
            paths: {
                '@/*': [
                    './src/*'
                ],
                '@components/*': [
                    './src/components/*'
                ]
            }
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.baseUrl, './src');
    _nodeassert.default.deepStrictEqual(result.jsc?.paths, {
        '@/*': [
            './src/*'
        ],
        '@components/*': [
            './src/components/*'
        ]
    });
});
(0, _nodetest.default)('source maps configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            sourceMap: true,
            inlineSources: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.sourceMaps, true);
    _nodeassert.default.strictEqual(result.inlineSourcesContent, true);
});
(0, _nodetest.default)('inline source maps configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            inlineSourceMap: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.sourceMaps, 'inline');
});
(0, _nodetest.default)('module interop configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            esModuleInterop: false,
            strict: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.module?.noInterop, true);
    _nodeassert.default.strictEqual(result.module?.strict, true);
});
(0, _nodetest.default)('external helpers configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            importHelpers: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.externalHelpers, true);
});
(0, _nodetest.default)('comments preservation', ()=>{
    const tsconfig = {
        compilerOptions: {
            removeComments: false
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.preserveAllComments, true);
});
(0, _nodetest.default)('class fields configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            useDefineForClassFields: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.transform?.useDefineForClassFields, true);
});
(0, _nodetest.default)('const enum preservation', ()=>{
    const tsconfig = {
        compilerOptions: {
            preserveConstEnums: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.transform?.treatConstEnumAsEnum, true);
});
(0, _nodetest.default)('target mapping for all ES versions', ()=>{
    const targets = [
        {
            ts: 'ES3',
            swc: 'es3'
        },
        {
            ts: 'ES5',
            swc: 'es5'
        },
        {
            ts: 'ES6',
            swc: 'es2015'
        },
        {
            ts: 'ES2015',
            swc: 'es2015'
        },
        {
            ts: 'ES2016',
            swc: 'es2016'
        },
        {
            ts: 'ES2017',
            swc: 'es2017'
        },
        {
            ts: 'ES2018',
            swc: 'es2018'
        },
        {
            ts: 'ES2019',
            swc: 'es2019'
        },
        {
            ts: 'ES2020',
            swc: 'es2020'
        },
        {
            ts: 'ES2021',
            swc: 'es2021'
        },
        {
            ts: 'ES2022',
            swc: 'es2022'
        },
        {
            ts: 'ESNext',
            swc: 'esnext'
        }
    ];
    for (const { ts, swc } of targets){
        const result = (0, _.default)({
            compilerOptions: {
                target: ts
            }
        });
        _nodeassert.default.strictEqual(result.jsc?.target, swc, `Target ${ts} should map to ${swc}`);
    }
});
(0, _nodetest.default)('module mapping for all module types', ()=>{
    const modules = [
        {
            ts: 'CommonJS',
            swc: 'commonjs'
        },
        {
            ts: 'AMD',
            swc: 'amd'
        },
        {
            ts: 'UMD',
            swc: 'umd'
        },
        {
            ts: 'ES6',
            swc: 'es6'
        },
        {
            ts: 'ES2015',
            swc: 'es6'
        },
        {
            ts: 'ES2020',
            swc: 'es6'
        },
        {
            ts: 'NodeNext',
            swc: 'nodenext'
        },
        {
            ts: 'Node16',
            swc: 'nodenext'
        }
    ];
    for (const { ts, swc } of modules){
        const result = (0, _.default)({
            compilerOptions: {
                module: ts
            }
        });
        _nodeassert.default.strictEqual(result.module?.type, swc, `Module ${ts} should map to ${swc}`);
    }
});
(0, _nodetest.default)('JSX mapping for all JSX modes', ()=>{
    const jsxModes = [
        {
            ts: 'React',
            expectJsx: true,
            expectTsx: true,
            expectRuntime: 'classic'
        },
        {
            ts: 'ReactJSX',
            expectJsx: true,
            expectTsx: true,
            expectRuntime: 'automatic'
        },
        {
            ts: 'ReactJSXDev',
            expectJsx: true,
            expectTsx: true,
            expectRuntime: 'automatic',
            expectDev: true
        },
        {
            ts: 'Preserve',
            expectJsx: true,
            expectTsx: true,
            expectRuntime: undefined
        },
        {
            ts: 'None',
            expectJsx: false,
            expectTsx: false,
            expectRuntime: undefined
        }
    ];
    for (const mode of jsxModes){
        const result = (0, _.default)({
            compilerOptions: {
                jsx: mode.ts
            }
        });
        _nodeassert.default.strictEqual(result.jsc?.parser?.jsx, mode.expectJsx, `JSX ${mode.ts} should set jsx to ${mode.expectJsx}`);
        _nodeassert.default.strictEqual(result.jsc?.parser?.tsx, mode.expectTsx, `JSX ${mode.ts} should set tsx to ${mode.expectTsx}`);
        if (mode.expectRuntime) {
            _nodeassert.default.strictEqual(result.jsc?.transform?.react?.runtime, mode.expectRuntime, `JSX ${mode.ts} should set runtime to ${mode.expectRuntime}`);
            if (mode.expectDev) {
                _nodeassert.default.strictEqual(result.jsc?.transform?.react?.development, true, `JSX ${mode.ts} should set development to true`);
            }
        } else {
            _nodeassert.default.strictEqual(result.jsc?.transform?.react, undefined, `JSX ${mode.ts} should not set react transform`);
        }
    }
});
(0, _nodetest.default)('comprehensive real-world Node.js configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES2020',
            module: 'CommonJS',
            lib: [
                'ES2020'
            ],
            moduleResolution: 'Node',
            esModuleInterop: true,
            allowSyntheticDefaultImports: true,
            strict: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
            declaration: true,
            declarationMap: true,
            outDir: 'dist',
            rootDir: 'src',
            sourceMap: true,
            importHelpers: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.target, 'es2020');
    _nodeassert.default.strictEqual(result.module?.type, 'commonjs');
    _nodeassert.default.strictEqual(result.sourceMaps, true);
    _nodeassert.default.strictEqual(result.jsc?.externalHelpers, true);
});
(0, _nodetest.default)('comprehensive React application configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES2020',
            lib: [
                'DOM',
                'DOM.Iterable',
                'ES6'
            ],
            allowJs: true,
            skipLibCheck: true,
            esModuleInterop: true,
            allowSyntheticDefaultImports: true,
            strict: true,
            forceConsistentCasingInFileNames: true,
            noFallthroughCasesInSwitch: true,
            module: 'ESNext',
            moduleResolution: 'Node',
            resolveJsonModule: true,
            isolatedModules: true,
            noEmit: true,
            jsx: 'ReactJSX',
            jsxImportSource: '@emotion/react'
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.target, 'es2020');
    _nodeassert.default.strictEqual(result.module?.type, 'es6');
    _nodeassert.default.strictEqual(result.jsc?.parser?.jsx, true);
    _nodeassert.default.strictEqual(result.jsc?.transform?.react?.runtime, 'automatic');
    _nodeassert.default.strictEqual(result.jsc?.transform?.react?.importSource, '@emotion/react');
});
(0, _nodetest.default)('library configuration with decorators', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES2017',
            module: 'UMD',
            lib: [
                'ES2017'
            ],
            declaration: true,
            outDir: './lib',
            strict: true,
            experimentalDecorators: true,
            emitDecoratorMetadata: true,
            useDefineForClassFields: false,
            preserveConstEnums: true
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.target, 'es2017');
    _nodeassert.default.strictEqual(result.module?.type, 'umd');
    _nodeassert.default.strictEqual(result.jsc?.parser?.decorators, true);
    _nodeassert.default.strictEqual(result.jsc?.transform?.legacyDecorator, true);
    _nodeassert.default.strictEqual(result.jsc?.transform?.decoratorMetadata, true);
    _nodeassert.default.strictEqual(result.jsc?.transform?.useDefineForClassFields, false);
    _nodeassert.default.strictEqual(result.jsc?.transform?.treatConstEnumAsEnum, true);
});
(0, _nodetest.default)('empty compilerOptions should use defaults', ()=>{
    const tsconfig = {};
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.target, 'es5');
    _nodeassert.default.strictEqual(result.jsc?.parser?.syntax, 'typescript');
});
(0, _nodetest.default)('minimal compilerOptions should work', ()=>{
    const tsconfig = {
        compilerOptions: {}
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.target, 'es5');
    _nodeassert.default.strictEqual(result.jsc?.parser?.syntax, 'typescript');
});
(0, _nodetest.default)('ES3 target conversion', ()=>{
    const tsconfig = {
        compilerOptions: {
            target: 'ES3'
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.target, 'es3');
});
(0, _nodetest.default)('complex JSX factory configuration', ()=>{
    const tsconfig = {
        compilerOptions: {
            jsx: 'React',
            jsxFactory: 'h',
            jsxFragmentFactory: 'Fragment'
        }
    };
    const result = (0, _.default)(tsconfig);
    _nodeassert.default.strictEqual(result.jsc?.transform?.react?.runtime, 'classic');
    _nodeassert.default.strictEqual(result.jsc?.transform?.react?.pragma, 'h');
    _nodeassert.default.strictEqual(result.jsc?.transform?.react?.pragmaFrag, 'Fragment');
});
(0, _nodetest.default)('syntax detection based on TypeScript features', ()=>{
    const tsconfigWithTSFeatures = {
        compilerOptions: {
            experimentalDecorators: true,
            strictNullChecks: true
        }
    };
    const result = (0, _.default)(tsconfigWithTSFeatures);
    _nodeassert.default.strictEqual(result.jsc?.parser?.syntax, 'typescript');
    const tsconfigMinimal = {
        compilerOptions: {
            target: 'ES2020'
        }
    };
    const result2 = (0, _.default)(tsconfigMinimal);
    _nodeassert.default.strictEqual(result2.jsc?.parser?.syntax, 'typescript');
});
(0, _nodetest.default)('returns valid SWC JscTarget types', ()=>{
    const validTargets = [
        'es3',
        'es5',
        'es2015',
        'es2016',
        'es2017',
        'es2018',
        'es2019',
        'es2020',
        'es2021',
        'es2022',
        'esnext'
    ];
    const tsconfig = {
        compilerOptions: {
            target: 'ES2020'
        }
    };
    const result = (0, _.default)(tsconfig);
    // Verify the target is one of the valid JscTarget values
    (0, _nodeassert.default)(validTargets.includes(result.jsc?.target), `Target ${result.jsc?.target} should be a valid JscTarget`);
    // Verify it's specifically es2020 for ES2020 input
    _nodeassert.default.strictEqual(result.jsc?.target, 'es2020');
});
