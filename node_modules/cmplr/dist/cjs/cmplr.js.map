{"version":3,"sources":["../../bin/cmplr.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { promises as fs } from \"node:fs\";\nimport * as path from \"path\";\nimport { execSync } from \"child_process\";\nimport convert, { TSConfig } from \"tsconfig-swc\";\n\ninterface SWCConfig {\n  jsc: {\n    parser: {\n      syntax: \"typescript\" | \"ecmascript\";\n      tsx?: boolean;\n      jsx?: boolean;\n      decorators?: boolean;\n    };\n    target: string;\n    loose?: boolean;\n    externalHelpers?: boolean;\n  };\n  module: {\n    type: \"commonjs\" | \"es6\";\n  };\n  sourceMaps: boolean;\n  exclude?: string[];\n}\n\ninterface CLIArgs {\n  dryRun: boolean;\n  help: boolean;\n  version: boolean;\n  srcDir?: string;\n  outDir: string;\n  noTypes: boolean;\n}\n\nconst fileExists = async (filePath: string): Promise<boolean> => {\n  try {\n    await fs.access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nconst parseArgs = (): CLIArgs => {\n  const args = process.argv.slice(2);\n  const parsed: CLIArgs = {\n    dryRun: false,\n    help: false,\n    version: false,\n    outDir: \"dist\",\n    noTypes: false,\n  };\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    switch (arg) {\n      case \"--dry-run\":\n        parsed.dryRun = true;\n        break;\n      case \"--help\":\n      case \"-h\":\n        parsed.help = true;\n        break;\n      case \"--version\":\n      case \"-v\":\n        parsed.version = true;\n        break;\n      case \"--src-dir\":\n        parsed.srcDir = args[++i];\n        break;\n      case \"--out-dir\":\n        parsed.outDir = args[++i];\n        break;\n      case \"--no-types\":\n        parsed.noTypes = true;\n        break;\n      default:\n        if (arg.startsWith(\"--\")) {\n          console.error(`Unknown option: ${arg}`);\n          process.exit(1);\n        }\n    }\n  }\n\n  return parsed;\n};\n\nconst showHelp = () => {\n  console.log(`\ncmplr - Speedy web compiler without the config\n\nUsage: cmplr [options]\n\nOptions:\n  --dry-run      Show what would be compiled without executing\n  --help, -h     Show this help message\n  --version, -v  Show version number\n  --src-dir      Source directory (default: auto-detect from tsconfig or 'src')\n  --out-dir      Output directory (default: 'dist')\n  --no-types     Skip TypeScript declaration generation\n\nExamples:\n  cmplr                    # Compile with auto-detected settings (automatically cleans output)\n  cmplr --dry-run          # Preview compilation\n  cmplr --src-dir lib      # Use 'lib' as source directory\n`);\n};\n\nconst showVersion = async () => {\n  const content = await fs.readFile(\n    path.join(__dirname, \"../../package.json\"),\n    \"utf8\"\n  );\n  const packageJson = JSON.parse(content);\n  console.log(packageJson.version);\n};\n\nconst readTSConfig = async (): Promise<TSConfig | null> => {\n  const tsconfigPath = path.join(process.cwd(), \"tsconfig.json\");\n  if (!(await fileExists(tsconfigPath))) {\n    return null;\n  }\n\n  try {\n    const content = await fs.readFile(tsconfigPath, \"utf8\");\n    return JSON.parse(content);\n  } catch (error) {\n    console.warn(\"Warning: Could not parse tsconfig.json, using defaults\");\n    return null;\n  }\n};\n\nconst detectSourceDir = async (\n  tsconfig: TSConfig | null,\n  srcDirArg?: string\n): Promise<string> => {\n  if (srcDirArg) return srcDirArg;\n\n  if (tsconfig?.compilerOptions?.rootDir) {\n    return tsconfig.compilerOptions.rootDir;\n  }\n\n  if (await fileExists(\"src\")) return \"src\";\n  if (await fileExists(\"lib\")) return \"lib\";\n  if (await fileExists(\"bin\")) return \"bin\";\n\n  return \"src\";\n};\n\nconst createSWCConfig = async (\n  tsconfig: TSConfig | null,\n  moduleType: \"commonjs\" | \"es6\",\n  srcDir: string\n): Promise<SWCConfig> => {\n  let files: string[] = [];\n  if (await fileExists(srcDir)) {\n    const dirents = await fs.readdir(srcDir, { withFileTypes: true });\n    files = dirents\n      .filter((dirent) => dirent.isFile())\n      .map((dirent) => dirent.name);\n  }\n\n  const hasTypeScript = files.some(\n    (file) => file.endsWith(\".ts\") || file.endsWith(\".tsx\")\n  );\n  const hasTSX = files.some((file) => file.endsWith(\".tsx\"));\n  const hasJSX = files.some(\n    (file) => file.endsWith(\".jsx\") || file.endsWith(\".tsx\")\n  );\n\n  // Use tsconfig-swc to convert TypeScript config to SWC config\n  let baseConfig: any = {};\n  if (tsconfig) {\n    try {\n      baseConfig = convert(tsconfig);\n    } catch (error) {\n      console.warn(\n        \"Warning: Could not convert tsconfig with tsconfig-swc, using fallback\"\n      );\n    }\n  }\n\n  // Override with our specific requirements and auto-detected settings\n  const config: SWCConfig = {\n    ...baseConfig,\n    jsc: {\n      ...baseConfig.jsc,\n      parser: {\n        ...baseConfig.jsc?.parser,\n        syntax: hasTypeScript ? \"typescript\" : \"ecmascript\",\n        tsx: hasTSX,\n        jsx: hasJSX,\n        decorators:\n          baseConfig.jsc?.parser?.decorators ??\n          (tsconfig?.compilerOptions?.experimentalDecorators || false),\n      },\n      target: baseConfig.jsc?.target || \"es2020\",\n      loose: baseConfig.jsc?.loose ?? false,\n      externalHelpers: baseConfig.jsc?.externalHelpers ?? false,\n    },\n    module: {\n      type: moduleType, // Always override module type for dual compilation\n    },\n    sourceMaps: baseConfig.sourceMaps ?? true,\n  };\n\n  if (tsconfig?.exclude) {\n    config.exclude = tsconfig.exclude;\n  }\n\n  return config;\n};\n\nconst detectEntryPoints = async (srcDir: string): Promise<string[]> => {\n  if (!(await fileExists(srcDir))) {\n    throw new Error(`Source directory '${srcDir}' does not exist`);\n  }\n\n  const dirents = await fs.readdir(srcDir, { withFileTypes: true });\n  const files = dirents\n    .filter((dirent) => dirent.isFile())\n    .map((dirent) => dirent.name)\n    .filter(\n      (file) =>\n        /\\.(ts|tsx|js|jsx)$/.test(file) &&\n        !file.includes(\".test.\") &&\n        !file.includes(\".spec.\")\n    );\n\n  // If there's an index file, return all files (index + other entry points)\n  const indexFile = files.find((file) => file.startsWith(\"index.\"));\n  if (indexFile) {\n    return files; // Return all files including index\n  }\n\n  return files;\n};\n\nconst createTempSWCConfig = async (\n  config: SWCConfig,\n  configName: string\n): Promise<string> => {\n  const tempDir = path.join(__dirname, \"../.temp\");\n  if (!(await fileExists(tempDir))) {\n    await fs.mkdir(tempDir, { recursive: true });\n  }\n\n  const configPath = path.join(tempDir, `${configName}.swcrc`);\n  await fs.writeFile(configPath, JSON.stringify(config, null, 2));\n  return configPath;\n};\n\nconst cleanupTempConfigs = async () => {\n  const tempDir = path.join(__dirname, \"../.temp\");\n  if (await fileExists(tempDir)) {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  }\n};\n\nconst updatePackageJsonExports = async (\n  entryPoints: string[],\n  outDir: string,\n  noTypes: boolean\n) => {\n  const packageJsonPath = path.join(process.cwd(), \"package.json\");\n  if (!(await fileExists(packageJsonPath))) {\n    console.warn(\"Warning: package.json not found, skipping exports update\");\n    return;\n  }\n\n  const content = await fs.readFile(packageJsonPath, \"utf8\");\n  const packageJson = JSON.parse(content);\n\n  if (entryPoints.length === 1 && entryPoints[0].startsWith(\"index.\")) {\n    const baseName = path.parse(entryPoints[0]).name;\n    packageJson.main = `./${outDir}/cjs/${baseName}.js`;\n    packageJson.module = `./${outDir}/esm/${baseName}.js`;\n    if (!noTypes) {\n      packageJson.types = `./${outDir}/types/${baseName}.d.ts`;\n    }\n\n    packageJson.exports = {\n      \".\": {\n        import: `./${outDir}/esm/${baseName}.js`,\n        require: `./${outDir}/cjs/${baseName}.js`,\n        ...(noTypes ? {} : { types: `./${outDir}/types/${baseName}.d.ts` }),\n      },\n    };\n  } else {\n    packageJson.exports = {};\n    entryPoints.forEach((entry) => {\n      const baseName = path.parse(entry).name;\n      const exportKey = baseName === \"index\" ? \".\" : `./${baseName}`;\n      packageJson.exports[exportKey] = {\n        import: `./${outDir}/esm/${baseName}.js`,\n        require: `./${outDir}/cjs/${baseName}.js`,\n        ...(noTypes ? {} : { types: `./${outDir}/types/${baseName}.d.ts` }),\n      };\n    });\n\n    const mainEntry =\n      entryPoints.find((e) => e.startsWith(\"index.\")) || entryPoints[0];\n    const mainBaseName = path.parse(mainEntry).name;\n    packageJson.main = `./${outDir}/cjs/${mainBaseName}.js`;\n    packageJson.module = `./${outDir}/esm/${mainBaseName}.js`;\n    if (!noTypes) {\n      packageJson.types = `./${outDir}/types/${mainBaseName}.d.ts`;\n    }\n  }\n\n  await fs.writeFile(\n    packageJsonPath,\n    JSON.stringify(packageJson, null, 2) + \"\\n\"\n  );\n};\n\nconst main = async () => {\n  const args = parseArgs();\n\n  if (args.help) {\n    showHelp();\n    return;\n  }\n\n  if (args.version) {\n    await showVersion();\n    return;\n  }\n\n  const tsconfig = await readTSConfig();\n  const srcDir = await detectSourceDir(tsconfig, args.srcDir);\n  const entryPoints = await detectEntryPoints(srcDir);\n\n  if (args.dryRun) {\n    console.log(\"Dry run - would compile:\");\n    console.log(`  Source: ${srcDir}`);\n    console.log(`  Output: ${args.outDir}`);\n    console.log(`  Entry points: ${entryPoints.join(\", \")}`);\n    console.log(`  TypeScript config: ${tsconfig ? \"found\" : \"not found\"}`);\n    console.log(`  Generate types: ${!args.noTypes}`);\n    return;\n  }\n\n  try {\n    // Always clean output directory before compilation\n    if (await fileExists(args.outDir)) {\n      console.log(`Cleaning ${args.outDir}...`);\n      await fs.rm(args.outDir, { recursive: true, force: true });\n    }\n\n    const cjsConfig = await createSWCConfig(tsconfig, \"commonjs\", srcDir);\n    const esmConfig = await createSWCConfig(tsconfig, \"es6\", srcDir);\n\n    const cjsConfigPath = await createTempSWCConfig(cjsConfig, \"cjs\");\n    const esmConfigPath = await createTempSWCConfig(esmConfig, \"esm\");\n\n    console.log(\"Compiling CommonJS...\");\n    execSync(\n      `npx swc ${srcDir} -d ${args.outDir}/cjs --config-file ${cjsConfigPath} --strip-leading-paths`,\n      { stdio: \"inherit\" }\n    );\n\n    console.log(\"Compiling ESM...\");\n    execSync(\n      `npx swc ${srcDir} -d ${args.outDir}/esm --config-file ${esmConfigPath} --strip-leading-paths`,\n      { stdio: \"inherit\" }\n    );\n\n    if (!args.noTypes && tsconfig) {\n      console.log(\"Generating TypeScript declarations...\");\n      const tscCommand = `npx tsc --declaration --emitDeclarationOnly --outDir ${args.outDir}/types`;\n      execSync(tscCommand, { stdio: \"inherit\" });\n    }\n\n    await updatePackageJsonExports(entryPoints, args.outDir, args.noTypes);\n\n    console.log(\"Compilation complete!\");\n  } catch (error) {\n    console.error(\"Compilation failed:\", error);\n    process.exit(1);\n  } finally {\n    await cleanupTempConfigs();\n  }\n};\n\nif (require.main === module) {\n  main().catch((error) => {\n    console.error(\"Unexpected error:\", error);\n    process.exit(1);\n  });\n}\n"],"names":["fileExists","filePath","fs","access","parseArgs","args","process","argv","slice","parsed","dryRun","help","version","outDir","noTypes","i","length","arg","srcDir","startsWith","console","error","exit","showHelp","log","showVersion","content","readFile","path","join","__dirname","packageJson","JSON","parse","readTSConfig","tsconfigPath","cwd","warn","detectSourceDir","tsconfig","srcDirArg","compilerOptions","rootDir","createSWCConfig","moduleType","files","dirents","readdir","withFileTypes","filter","dirent","isFile","map","name","hasTypeScript","some","file","endsWith","hasTSX","hasJSX","baseConfig","convert","config","jsc","parser","syntax","tsx","jsx","decorators","experimentalDecorators","target","loose","externalHelpers","module","type","sourceMaps","exclude","detectEntryPoints","Error","test","includes","indexFile","find","createTempSWCConfig","configName","tempDir","mkdir","recursive","configPath","writeFile","stringify","cleanupTempConfigs","rm","force","updatePackageJsonExports","entryPoints","packageJsonPath","baseName","main","types","exports","import","require","forEach","entry","exportKey","mainEntry","e","mainBaseName","cjsConfig","esmConfig","cjsConfigPath","esmConfigPath","execSync","stdio","tscCommand","catch"],"mappings":"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"}