{"version":3,"sources":["../../bin/cmplr.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { promises as fs } from \"node:fs\";\nimport * as path from \"path\";\nimport { execSync } from \"child_process\";\nimport convert, { TSConfig } from \"tsconfig-swc\";\n\ninterface SWCConfig {\n  jsc: {\n    parser: {\n      syntax: \"typescript\" | \"ecmascript\";\n      tsx?: boolean;\n      jsx?: boolean;\n      decorators?: boolean;\n    };\n    target: string;\n    loose?: boolean;\n    externalHelpers?: boolean;\n  };\n  module: {\n    type: \"commonjs\" | \"es6\";\n  };\n  sourceMaps: boolean;\n  exclude?: string[];\n}\n\ninterface CLIArgs {\n  dryRun: boolean;\n  help: boolean;\n  version: boolean;\n  srcDir?: string;\n  outDir: string;\n  noTypes: boolean;\n}\n\nconst fileExists = async (filePath: string): Promise<boolean> => {\n  try {\n    await fs.access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nconst parseArgs = (): CLIArgs => {\n  const args = process.argv.slice(2);\n  const parsed: CLIArgs = {\n    dryRun: false,\n    help: false,\n    version: false,\n    outDir: \"dist\",\n    noTypes: false,\n  };\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    switch (arg) {\n      case \"--dry-run\":\n        parsed.dryRun = true;\n        break;\n      case \"--help\":\n      case \"-h\":\n        parsed.help = true;\n        break;\n      case \"--version\":\n      case \"-v\":\n        parsed.version = true;\n        break;\n      case \"--src-dir\":\n        parsed.srcDir = args[++i];\n        break;\n      case \"--out-dir\":\n        parsed.outDir = args[++i];\n        break;\n      case \"--no-types\":\n        parsed.noTypes = true;\n        break;\n      default:\n        if (arg.startsWith(\"--\")) {\n          console.error(`Unknown option: ${arg}`);\n          process.exit(1);\n        }\n    }\n  }\n\n  return parsed;\n};\n\nconst showHelp = () => {\n  console.log(`\ncmplr - Speedy web compiler without the config\n\nUsage: cmplr [options]\n\nOptions:\n  --dry-run      Show what would be compiled without executing\n  --help, -h     Show this help message\n  --version, -v  Show version number\n  --src-dir      Source directory (default: auto-detect from tsconfig or 'src')\n  --out-dir      Output directory (default: 'dist')\n  --no-types     Skip TypeScript declaration generation\n\nExamples:\n  cmplr                    # Compile with auto-detected settings (automatically cleans output)\n  cmplr --dry-run          # Preview compilation\n  cmplr --src-dir lib      # Use 'lib' as source directory\n`);\n};\n\nconst showVersion = async () => {\n  const content = await fs.readFile(\n    path.join(__dirname, \"../../package.json\"),\n    \"utf8\"\n  );\n  const packageJson = JSON.parse(content);\n  console.log(packageJson.version);\n};\n\nconst readTSConfig = async (): Promise<TSConfig | null> => {\n  const tsconfigPath = path.join(process.cwd(), \"tsconfig.json\");\n  if (!(await fileExists(tsconfigPath))) {\n    return null;\n  }\n\n  try {\n    const content = await fs.readFile(tsconfigPath, \"utf8\");\n    return JSON.parse(content);\n  } catch (error) {\n    console.warn(\"Warning: Could not parse tsconfig.json, using defaults\");\n    return null;\n  }\n};\n\nconst detectSourceDir = async (\n  tsconfig: TSConfig | null,\n  srcDirArg?: string\n): Promise<string> => {\n  if (srcDirArg) return srcDirArg;\n\n  if (tsconfig?.compilerOptions?.rootDir) {\n    return tsconfig.compilerOptions.rootDir;\n  }\n\n  if (await fileExists(\"src\")) return \"src\";\n  if (await fileExists(\"lib\")) return \"lib\";\n  if (await fileExists(\"bin\")) return \"bin\";\n\n  return \"src\";\n};\n\nconst createSWCConfig = async (\n  tsconfig: TSConfig | null,\n  moduleType: \"commonjs\" | \"es6\",\n  srcDir: string\n): Promise<SWCConfig> => {\n  let files: string[] = [];\n  if (await fileExists(srcDir)) {\n    const dirents = await fs.readdir(srcDir, { withFileTypes: true });\n    files = dirents\n      .filter((dirent) => dirent.isFile())\n      .map((dirent) => dirent.name);\n  }\n\n  const hasTypeScript = files.some(\n    (file) => file.endsWith(\".ts\") || file.endsWith(\".tsx\")\n  );\n  const hasTSX = files.some((file) => file.endsWith(\".tsx\"));\n  const hasJSX = files.some(\n    (file) => file.endsWith(\".jsx\") || file.endsWith(\".tsx\")\n  );\n\n  // Use tsconfig-swc to convert TypeScript config to SWC config\n  let baseConfig: any = {};\n  if (tsconfig) {\n    try {\n      baseConfig = convert(tsconfig);\n    } catch (error) {\n      console.warn(\n        \"Warning: Could not convert tsconfig with tsconfig-swc, using fallback\"\n      );\n    }\n  }\n\n  // Override with our specific requirements and auto-detected settings\n  const config: SWCConfig = {\n    ...baseConfig,\n    jsc: {\n      ...baseConfig.jsc,\n      parser: {\n        ...baseConfig.jsc?.parser,\n        syntax: hasTypeScript ? \"typescript\" : \"ecmascript\",\n        tsx: hasTSX,\n        jsx: hasJSX,\n        decorators:\n          baseConfig.jsc?.parser?.decorators ??\n          (tsconfig?.compilerOptions?.experimentalDecorators || false),\n      },\n      target: baseConfig.jsc?.target || \"es2020\",\n      loose: baseConfig.jsc?.loose ?? false,\n      externalHelpers: baseConfig.jsc?.externalHelpers ?? false,\n    },\n    module: {\n      type: moduleType, // Always override module type for dual compilation\n    },\n    sourceMaps: baseConfig.sourceMaps ?? true,\n  };\n\n  if (tsconfig?.exclude) {\n    config.exclude = tsconfig.exclude;\n  }\n\n  return config;\n};\n\nconst detectEntryPoints = async (srcDir: string): Promise<string[]> => {\n  if (!(await fileExists(srcDir))) {\n    throw new Error(`Source directory '${srcDir}' does not exist`);\n  }\n\n  const dirents = await fs.readdir(srcDir, { withFileTypes: true });\n  const files = dirents\n    .filter((dirent) => dirent.isFile())\n    .map((dirent) => dirent.name)\n    .filter(\n      (file) =>\n        /\\.(ts|tsx|js|jsx)$/.test(file) &&\n        !file.includes(\".test.\") &&\n        !file.includes(\".spec.\")\n    );\n\n  // If there's an index file, return all files (index + other entry points)\n  const indexFile = files.find((file) => file.startsWith(\"index.\"));\n  if (indexFile) {\n    return files; // Return all files including index\n  }\n\n  return files;\n};\n\nconst createTempSWCConfig = async (\n  config: SWCConfig,\n  configName: string\n): Promise<string> => {\n  const tempDir = path.join(__dirname, \"../.temp\");\n  if (!(await fileExists(tempDir))) {\n    await fs.mkdir(tempDir, { recursive: true });\n  }\n\n  const configPath = path.join(tempDir, `${configName}.swcrc`);\n  await fs.writeFile(configPath, JSON.stringify(config, null, 2));\n  return configPath;\n};\n\nconst cleanupTempConfigs = async () => {\n  const tempDir = path.join(__dirname, \"../.temp\");\n  if (await fileExists(tempDir)) {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  }\n};\n\nconst updatePackageJsonExports = async (\n  entryPoints: string[],\n  outDir: string,\n  noTypes: boolean\n) => {\n  const packageJsonPath = path.join(process.cwd(), \"package.json\");\n  if (!(await fileExists(packageJsonPath))) {\n    console.warn(\"Warning: package.json not found, skipping exports update\");\n    return;\n  }\n\n  const content = await fs.readFile(packageJsonPath, \"utf8\");\n  const packageJson = JSON.parse(content);\n\n  if (entryPoints.length === 1 && entryPoints[0].startsWith(\"index.\")) {\n    const baseName = path.parse(entryPoints[0]).name;\n    packageJson.main = `./${outDir}/cjs/${baseName}.js`;\n    packageJson.module = `./${outDir}/esm/${baseName}.js`;\n    if (!noTypes) {\n      packageJson.types = `./${outDir}/types/${baseName}.d.ts`;\n    }\n\n    packageJson.exports = {\n      \".\": {\n        import: `./${outDir}/esm/${baseName}.js`,\n        require: `./${outDir}/cjs/${baseName}.js`,\n        ...(noTypes ? {} : { types: `./${outDir}/types/${baseName}.d.ts` }),\n      },\n    };\n  } else {\n    packageJson.exports = {};\n    entryPoints.forEach((entry) => {\n      const baseName = path.parse(entry).name;\n      const exportKey = baseName === \"index\" ? \".\" : `./${baseName}`;\n      packageJson.exports[exportKey] = {\n        import: `./${outDir}/esm/${baseName}.js`,\n        require: `./${outDir}/cjs/${baseName}.js`,\n        ...(noTypes ? {} : { types: `./${outDir}/types/${baseName}.d.ts` }),\n      };\n    });\n\n    const mainEntry =\n      entryPoints.find((e) => e.startsWith(\"index.\")) || entryPoints[0];\n    const mainBaseName = path.parse(mainEntry).name;\n    packageJson.main = `./${outDir}/cjs/${mainBaseName}.js`;\n    packageJson.module = `./${outDir}/esm/${mainBaseName}.js`;\n    if (!noTypes) {\n      packageJson.types = `./${outDir}/types/${mainBaseName}.d.ts`;\n    }\n  }\n\n  await fs.writeFile(\n    packageJsonPath,\n    JSON.stringify(packageJson, null, 2) + \"\\n\"\n  );\n};\n\nconst main = async () => {\n  const args = parseArgs();\n\n  if (args.help) {\n    showHelp();\n    return;\n  }\n\n  if (args.version) {\n    await showVersion();\n    return;\n  }\n\n  const tsconfig = await readTSConfig();\n  const srcDir = await detectSourceDir(tsconfig, args.srcDir);\n  const entryPoints = await detectEntryPoints(srcDir);\n\n  if (args.dryRun) {\n    console.log(\"Dry run - would compile:\");\n    console.log(`  Source: ${srcDir}`);\n    console.log(`  Output: ${args.outDir}`);\n    console.log(`  Entry points: ${entryPoints.join(\", \")}`);\n    console.log(`  TypeScript config: ${tsconfig ? \"found\" : \"not found\"}`);\n    console.log(`  Generate types: ${!args.noTypes}`);\n    return;\n  }\n\n  try {\n    // Always clean output directory before compilation\n    if (await fileExists(args.outDir)) {\n      console.log(`Cleaning ${args.outDir}...`);\n      await fs.rm(args.outDir, { recursive: true, force: true });\n    }\n\n    const cjsConfig = await createSWCConfig(tsconfig, \"commonjs\", srcDir);\n    const esmConfig = await createSWCConfig(tsconfig, \"es6\", srcDir);\n\n    const cjsConfigPath = await createTempSWCConfig(cjsConfig, \"cjs\");\n    const esmConfigPath = await createTempSWCConfig(esmConfig, \"esm\");\n\n    console.log(\"Compiling CommonJS...\");\n    execSync(\n      `npx swc ${srcDir} -d ${args.outDir}/cjs --config-file ${cjsConfigPath} --strip-leading-paths`,\n      { stdio: \"inherit\" }\n    );\n\n    console.log(\"Compiling ESM...\");\n    execSync(\n      `npx swc ${srcDir} -d ${args.outDir}/esm --config-file ${esmConfigPath} --strip-leading-paths`,\n      { stdio: \"inherit\" }\n    );\n\n    if (!args.noTypes && tsconfig) {\n      console.log(\"Generating TypeScript declarations...\");\n      const tscCommand = `npx tsc --declaration --emitDeclarationOnly --outDir ${args.outDir}/types`;\n      execSync(tscCommand, { stdio: \"inherit\" });\n    }\n\n    await updatePackageJsonExports(entryPoints, args.outDir, args.noTypes);\n\n    console.log(\"Compilation complete!\");\n  } catch (error) {\n    console.error(\"Compilation failed:\", error);\n    process.exit(1);\n  } finally {\n    await cleanupTempConfigs();\n  }\n};\n\nif (require.main === module) {\n  main().catch((error) => {\n    console.error(\"Unexpected error:\", error);\n    process.exit(1);\n  });\n}\n"],"names":["promises","fs","path","execSync","convert","fileExists","filePath","access","parseArgs","args","process","argv","slice","parsed","dryRun","help","version","outDir","noTypes","i","length","arg","srcDir","startsWith","console","error","exit","showHelp","log","showVersion","content","readFile","join","__dirname","packageJson","JSON","parse","readTSConfig","tsconfigPath","cwd","warn","detectSourceDir","tsconfig","srcDirArg","compilerOptions","rootDir","createSWCConfig","moduleType","files","dirents","readdir","withFileTypes","filter","dirent","isFile","map","name","hasTypeScript","some","file","endsWith","hasTSX","hasJSX","baseConfig","config","jsc","parser","syntax","tsx","jsx","decorators","experimentalDecorators","target","loose","externalHelpers","module","type","sourceMaps","exclude","detectEntryPoints","Error","test","includes","indexFile","find","createTempSWCConfig","configName","tempDir","mkdir","recursive","configPath","writeFile","stringify","cleanupTempConfigs","rm","force","updatePackageJsonExports","entryPoints","packageJsonPath","baseName","main","types","exports","import","require","forEach","entry","exportKey","mainEntry","e","mainBaseName","cjsConfig","esmConfig","cjsConfigPath","esmConfigPath","stdio","tscCommand","catch"],"mappings":"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"}